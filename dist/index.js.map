{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["\n/*\n  We do not do a Promise.all on all ids\n  requests will be done BATCH_SIZE by BATCH_SIZE\n*/\nconst BATCH_SIZE = 2;\n\nexport enum BeesLoadStatus {\n  Loading = \"loading\",\n  Failed = \"failed\",\n  Completed = \"completed\",\n}\n\nexport interface BeesLoadData {\n  type: \"SUCCESS\" | \"ERROR\";\n  status?: number;\n  data?: string;\n  stringToCompare?: string | undefined;\n  id: string;\n}\n\nexport interface BeesLoadCompleted {\n  [id: string]: {\n    ids: string[];\n    data: string;\n    stringToCompare: string | undefined;\n  };\n}\n\nexport interface BeesLoadErrors {\n  [id: string]: {\n    id: string;\n    status?: number;\n  };\n}\n\nexport enum BeesLoadError {\n  OutOfNodes = \"Out of nodes\",\n  UnaccurateState = \"Unaccurate state\",\n}\n\nexport interface BeesLoadErrorWithArgs {\n  error: BeesLoadError;\n  args: { [key: string]: any };\n}\n\nexport interface ResolverOutput {\n  loadState: BeesLoadCompleted;\n  loadErrors: BeesLoadErrors;\n  loadPending: string[];\n  loadError?: BeesLoadErrorWithArgs;\n  status: BeesLoadStatus;\n}\n\nconst indexData = (\n  data: BeesLoadData,\n  existingData: BeesLoadCompleted,\n  comparer?: (x: string | undefined) => any\n): BeesLoadCompleted => {\n  let found = false;\n  let stringToCompare = data.data;\n\n  if (typeof comparer === \"function\") {\n    try {\n      stringToCompare = comparer(data.data);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // initialize existingData\n  if (Object.keys(existingData).length === 0) {\n    existingData = {\n      \"1\": {\n        ids: [data.id],\n        data: data.data || \"\",\n        stringToCompare: stringToCompare,\n      },\n    };\n  } else {\n    Object.keys(existingData).forEach((key) => {\n      if (stringToCompare === existingData[key].stringToCompare) {\n        found = true;\n        existingData = {\n          ...existingData,\n          [key]: {\n            ...existingData[key],\n            ids: existingData[key].ids.concat(data.id),\n          },\n        };\n      }\n    });\n  \n    if (!found) {\n      existingData = {\n        ...existingData,\n        [Object.keys(existingData).length + 1]: {\n          ids: [data.id],\n          data: data.data,\n          stringToCompare: stringToCompare,\n        },\n      };\n    }\n  }\n\n  return existingData;\n};\n\nexport const resolver = (\n  queryHandler: (urlToQuery: string) => Promise<BeesLoadData>,\n  ids: string[],\n  resolverAccuracy: number,\n  resolverAbsolute: number,\n  comparer?: (x: string | undefined) => any\n): Promise<ResolverOutput> => {\n  let loadErrors: BeesLoadErrors = {};\n  let loadState: BeesLoadCompleted = {};\n  let loadPending: string[] = [];\n\n  return new Promise((resolve, reject) => {\n\n    if (typeof resolverAccuracy !== \"number\" || resolverAccuracy < 50 || resolverAccuracy > 100) {\n      reject(\"resolverAccuracy should be a number (percentage) between 50 and 100\");\n      return;\n    }\n\n    if (typeof resolverAbsolute !== 'number' || !Number.isInteger(resolverAbsolute) || resolverAbsolute > ids.length) {\n      reject(\"resolverAbsolute should be an integer number and not exceed the length of ids\");\n      return;\n    }\n\n    let i = 0;\n\n    const callBatch = async (i: number) => {\n      // idsToQuery is of same size as resolverAbsolute\n      // but you can change this to do 3 by 3 or 4 by 4 etc.\n      const idsToQuery = ids.slice(i, i + BATCH_SIZE);\n\n      if (idsToQuery.length === 0) {\n        resolve({\n          loadErrors: loadErrors,\n          loadState: loadState,\n          loadPending: loadPending,\n          loadError: {\n            error: BeesLoadError.OutOfNodes,\n            args: {\n              alreadyQueried: i - Object.keys(loadErrors).length,\n              resolverAbsolute: resolverAbsolute,\n            },\n          },\n          status: BeesLoadStatus.Failed,\n        });\n        return;\n      }\n\n      i += idsToQuery.length;\n\n      loadPending = loadPending.concat(idsToQuery);\n\n      const responses = await Promise.all(idsToQuery.map(id => queryHandler(id)));\n\n      responses.forEach((data: BeesLoadData) => {\n        loadPending = loadPending.filter((id) => id !== data.id);\n\n        if (data.type === \"SUCCESS\") {\n          try {\n            loadState = indexData(data, loadState, comparer);\n          } catch (err) {\n            loadErrors = {\n              ...loadErrors,\n              [data.id]: {\n                id: data.id,\n                status: (err as any).message ? parseInt((err as any).message, 10) : 400,\n              },\n            };\n          }\n        } else {\n          loadErrors = {\n            ...loadErrors,\n            [data.id]: {\n              id: data.id,\n              status: data.status,\n            },\n          };\n        }\n\n      });\n\n      const totalOkResponses = Object.keys(loadState).reduce(\n        (total, k) => {\n          return total + loadState[k].ids.length;\n        },\n        0\n      );\n\n      // don't ruen this into a .forEach, return are\n      // not effecive in forEach loops\n      for (let j = 0; j < Object.keys(loadState).length; j += 1) {\n        const key = Object.keys(loadState)[j];\n\n        const nodesWithOkResponses = loadState[key].ids.length;\n\n        // at least [resolverAbsolute] responses of the same\n        // resolver must Complete or Fail\n        if (nodesWithOkResponses >= resolverAbsolute) {\n          if (\n            resolverAccuracy / 100 >\n            loadState[key].ids.length / totalOkResponses\n          ) {\n            resolve({\n              loadErrors: loadErrors,\n              loadState: loadState,\n              loadPending: loadPending,\n              loadError: {\n                error: BeesLoadError.UnaccurateState,\n                args: {\n                  totalOkResponses: totalOkResponses,\n                  loadStates: Object.keys(loadState).map((k) => {\n                    return {\n                      key: k,\n                      okResponses: loadState[k].ids.length,\n                      percent:\n                        Math.round(\n                          (100 *\n                            (100 * loadState[k].ids.length)) /\n                            totalOkResponses\n                        ) / 100,\n                    };\n                  }),\n                },\n              },\n              status: BeesLoadStatus.Failed,\n            });\n            // will stop for loop\n            return;\n          }\n\n          resolve({\n            loadErrors: loadErrors,\n            loadState: loadState,\n            loadPending: loadPending,\n            status: BeesLoadStatus.Completed,\n          });\n          // will stop for loop\n          return;\n        }\n      }\n\n      // if no return in for loop, go\n      // on next batch\n      callBatch(i);\n    };\n\n    callBatch(i);\n  });\n};\n"],"names":["BeesLoadStatus","BeesLoadError"],"mappings":"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"}